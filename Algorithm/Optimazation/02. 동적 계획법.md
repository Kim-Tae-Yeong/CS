# 동적 계획법
## 동적 계획법(DP, Dynamic Programming)
동적 계획법은 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것이다.

사실 일반적인 재귀 방식 또한 DP와 매우 유사하다.
하지만 큰 차이점은 일반적인 재귀를 단순히 사용시 동일한 작은 문제를 여러번 반복되어 비효율적인 계산이 될 수 있다.

예를 들어 피보나치 수열을 살펴보자.

피보나치 수를 재귀로 구하려면 단순히 f(n) = f(n - 1) + f(n -2)를 구하면 된다.

그러나 f(n - 1), f(n - 2)에서 각 함수를 한번씩 호출하면 동일한 값을 2번 구하게 된다.
이로 인해 100번째 피보나치 수를 구하기 위해 호출되는 함수의 횟수는 기하급수적으로 증가하게 된다.

그 이유는 아래의 그림처럼 f(n - 1)에서 한번 구한 값을 f(n - 2)에서 또 다시 또 다시 구하는 과정을 반복하기 때문이다.

<img width="568" alt="image" src="https://github.com/user-attachments/assets/fafe7293-3984-478f-b5a1-ffa30bbaa329" />

그러나 한번 구한 작은 문제의 결과 값을 저장해두고 재사용한다면 어떨까?
앞에서 계산된 값을 다시 반복할 필요가 없어 매우 효율적으로 문제를 해결할 수 있게 된다.

이렇게 이전에 계산된 값을 다시 구하기 않고 저장해두었다가 사용하는 기법을 메모이제이션(memoization)이라고 한다.

DP가 적용되기 위해서는 아래 2가지 조건을 만족해야 한다.

### 1. 중복되는 부분 문제(Overlapping Subproblems)
DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다.

따라서 동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능하다.

아래 그림에서 f(3), f(2), f(1)과 같은 동일한 부분 문제가 중복되어 나타난다.
그러므로 1회 계산했을 때 저장된 값을 재활용할 수 있게 되는 것이다.

<img width="577" alt="image" src="https://github.com/user-attachments/assets/e26fc438-d04f-4271-8f80-6be049c65aad" />

### 2. 최적 부분 구조(Optimal Substructure)
부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우를 의미한다.

예를 들어 A - B까지의 가장 짧은 경로를 찾는다고 해보자.

중간에 X가 있을 때, A - X / X - B(부분 문제의 최적 결과)가 많은 경로 중 가장 짧은 경로라면 전체 최적 경로도 A - X - B(전체 문제의 최적 경로)가 정답이 된다.

<img width="425" alt="image" src="https://github.com/user-attachments/assets/4abe1f19-ae30-4cfd-b8cb-b09696d3d056" />
