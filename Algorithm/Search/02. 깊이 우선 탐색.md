# 깊이 우선 탐색
## 깊이 우선 탐색(Depth - First Search, DFS)
깊이 우선 탐색은 **그래프에서 깊이를 우선적으로 탐색**하는 방법이다.

즉, **루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색**하는 방법이다.

이는 주로 **경로의 모든 경우를 탐색**할 때 사용한다.

## 과정
우선 DFS는 스택를 이용하여 구현한다.

아래와 같은 그래프가 있을 때, DFS 과정을 알아보자.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/9d82457e-9c2e-4037-b310-1a7071a3c924" />

먼저 루트 노드부터 탐색을 시작한다.
루트 노드를 방문하고 방문한 노드를 스택에 추가한다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/a2e1f2c6-926b-49e5-a1c2-edcab8da583a" />

이후 스택의 top에 있는 A 노드의 인접 노드인 B를 방문하고, 스택에 B 노드를 추가한다.(C 노드를 먼저 방문해도 상관 없다.)

<img width="550" alt="image" src="https://github.com/user-attachments/assets/d96d5228-b78b-4373-a3eb-491b7402587b" />

스택의 top에 있는 B 노드의 인접 노드인 D 노드를 방문하고 스택에 D 노드를 추가한다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/35108b70-6027-4dfe-8c66-3cc52e6da55c" />

여기서 D 노드에는 방문하지 않은 인접 노드가 없기 때문에 스택에서 D를 제거한다.
이는 B 노드로 돌아가는 것과 같다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/2d887e19-daa7-425d-8012-9c9e7de0d618" />

이후 다시 스택의 top에 있는 B 노드에서 인접한 노드 중 방문하지 않은 노드인 E 노드를 방문하고 스택에 추가한다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/c51863b7-acdf-40dc-98d8-00e5c4abb3e4" />

E 노드에는 더 이상 방문할 노드가 없기 때문에 E 노드를 스택에서 삭제하면서 B 노드로 돌아간다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/0140d536-c070-4d60-95cc-490715bb45dd" />

B 노드에서도 마찬가지로 더 이상 방문할 노드가 없기 때문에 B 노드를 스택에서 삭제하면서 A 노드로 돌아간다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/5f000750-bd42-4ca2-9859-be54bc293541" />

왼쪽과 동일한 방법으로 오른쪽을 탐색하면 된다.
A 노드에서 방문할 수 있는 C 노드를 방문하고 스택에 추가한다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/ae9d76db-dc4b-488b-89c9-bcb31ba478d5" />

이후 C 노드의 인접 노드인 F 노드를 먼저 방문하고 스택에 추가한다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/afe96da4-705a-4499-acba-2112c78dbdf9" />

F 노드에서는 더 이상 방문할 노드가 없기 때문에 F 노드를 스택에서 삭제하면서 C 노드로 돌아간다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/2b7c648b-6543-4624-87a2-f4af18681a20" />

C 노드와 인접한 노드 중 방문하지 않은 G 노드를 방문하고 스택에 추가한다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/d34d909e-a99a-4b61-b7d7-52028b753a5b" />

G 노드에서는 더 이상 방문할 노드가 없기 때문에 G 노드를 스택에서 삭제하면서 C 노드로 돌아간다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/b08074cd-bfd7-4e6f-a942-843c5a4e0735" />

C 노드에서도 마찬가지로 더 이상 방문할 노드가 없기 때문에 C 노드를 스택에서 삭제하면서 A 노드로 돌아간다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/a0d16fd0-f53d-46d1-a7eb-a097afc3c66f" />

A 노드에서도 마찬가지로 더 이상 방문할 노드가 없기 때문에 A 노드를 스택에서 삭제한다.

<img width="550" alt="image" src="https://github.com/user-attachments/assets/cb2f69fe-c850-49ed-83c8-cb405a6852b9" />

이렇게 스택에 아무 노드도 남지 않으면 탐색이 완료된다.

## 코드

```java
import java.util.*;

public class DFSStack {
    static List<List<Integer>> graph = new ArrayList<>();
    static boolean[] visited;

    public static void main(String[] args) {
        int n = 6; // 노드 개수
        visited = new boolean[n + 1];

        // 그래프 초기화
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<>());
        }

        // 간선 추가
        addEdge(1, 2);
        addEdge(1, 3);
        addEdge(2, 4);
        addEdge(2, 5);
        addEdge(3, 6);

        // DFS 실행
        System.out.println("DFS 탐색 순서:");
        dfs(1);
    }

    static void dfs(int start) {
        Stack<Integer> stack = new Stack<>();
        stack.push(start);

        while (!stack.isEmpty()) {
            int node = stack.pop();

            if (visited[node]) continue;
            visited[node] = true;
            System.out.print(node + " ");

            // 작은 숫자부터 방문하기 위해 오름차순 정렬
            List<Integer> neighbors = graph.get(node);
            Collections.sort(neighbors);

            for (int next : neighbors) {
                if (!visited[next]) {
                    stack.push(next);
                }
            }
        }
    }

    static void addEdge(int u, int v) {
        graph.get(u).add(v);
        graph.get(v).add(u); // 무방향 그래프
    }
}
```

```
  1  
 / \  
2   3  
|\   \  
4 5   6

DFS 탐색 순서:  
1 2 4 5 3 6  
```

## 시간 복잡도
너비 우선 탐색의 시간 복잡도는 그래프를 표현한 방법에 따라 달라진다.(V : 노드의 수, E : 간선의 수)
- 인접 리스트로 그래프 표현(위 코드) : **O(V + E)**
- 인접 행렬로 그래프 표현 : **O($V ^ 2$)**

## 문제
백준 4963 섬의 개수
- https://www.acmicpc.net/problem/4963

백준 9466 텀 프로젝트
- https://www.acmicpc.net/problem/9466

## 참고
- https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html
- https://songsite123.tistory.com/29
