# 해시 테이블
## 해시 테이블(Hash Table)
해시 테이블은 **(key, value)로 데이터를 저장하는 자료구조**로 **빠르게 데이터를 검색**할 수 있는 자료구조이다.

해시 테이블이 빠른 검색속도를 제공하는 이유는 내부적으로 배열을 사용하여 데이터를 저장하기 때문이다.

해시 테이블은 **각각의 key 값에 해시 함수를 적용해 배열의 고유한 index를 생성**하고, 이를 활용해 값을 저장하거나 검색하게 된다.

여기서 실제 값이 저장되는 장소를 버킷 또는 슬롯이라고 한다.

예를 들어 우리가 ("John Smith", "521-1234")인 데이터를 크기가 16인 해시 테이블에 저장한다고 해보자.

그러면 먼저 index = hash_function("John Smith") % 16 연산을 통해 index 값을 계산한다.

그리고 array[index] = "521-1234"로 전화번호를 저장하게 된다.

<img width="710" alt="image" src="https://github.com/user-attachments/assets/df097040-900f-455d-8bad-487ce79b796a" />

이러한 해싱 구조로 데이터를 저장하면 key 값으로 데이터를 찾을 때 해시 함수를 1번만 수행하면 되므로 매우 빠르게 데이터를 저장, 삭제, 조회할 수 있다.

## 해시 함수
해시 함수에서 중요한 것은 고유한 index 값을 설정하는 것이다.

해시 테이블에 사용되는 대표적인 해시 함수는 아래와 같다.

1. Division Method
   - 나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산한다.(주소 = 입력값 % 테이블의 크기)
   - 테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다.
  
2. Digit Folding
   - 각 key의 문자열을 ASCII 코드로 바꾸고 값을 합한 데이터를 테이블의 내의 주소로 사용한다.
  
3. Multiplication Method
   - 숫자로 된 key 값 k와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같은 계산을 한다.(h(k) = (kAmod1) x m)
  
4. Universal Hashing
   - 다수의 해시 함수를 만들어 집합 H에 넣어두고, 무작위로 해시 함수를 선택해 해시값을 만드는 기법이다.
  
## 해시값이 충돌하는 경우
그런데 만약 "John Smith"를 해시 함수를 돌려 나온 값과 "Mang Kyu"를 해시 함수를 돌려 나온 값이 동일하다면 어떻게 해야 할까?

해시 테이블에서는 충돌에 의한 문제를 분리 연결법과 개방 주소법 크게 2가지로 해결하고 있다.

### 분리 연결법(Seperate Chaining)
분리 연결법이란 **동일한 버킷의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장**하는 것이다.

<img width="710" alt="image" src="https://github.com/user-attachments/assets/166992df-36cc-4af2-a366-986fc91e2bc5" />

위 그림과 같이 동일한 버킷으로 접근을 한다면 데이터들을 연결해서 관리해주고 있다.

이러한 chaining 방식은 해**시 테이블의 확장이 필요없고 간단하게 구현이 가능하며 손쉽게 삭제할 수 있다는 장점**이 있다.

하지만 **데이터의 수가 많아져 동일한 버킷에 연결되는 데이터가 많아지면 그에 따라 더 많은 메모리 공간을 사용한다는 단점**이 있다.

### 개방 주소법(Open Addressing)
개방 주소법이란 추가적인 메모리를 사용하는 chaining 방식과 다르게 **비어있는 해시 테이블의 공간을 활용하는 방식**이다.

이를 구현하기 위한 대표적인 방법으로는 3가지 방식이 존재한다.

1. Linear Probing
   - 현재의 버킷 index로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장한다.
  
2. Quadratic Probing
   - 해시의 저장순서 폭을 제곱으로 저장하는 방식이다.
   - 예를 들어 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 $2^2$, $3^2$칸씩 옮기는 방식이다.
  
3. Double Hashing Probing
   - 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다.
   - 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.
  
<img width="710" alt="image" src="https://github.com/user-attachments/assets/621dea8e-0840-40f6-bc48-2c7336ad362c" />

개방 주소법에서 **데이터를 삭제하면 삭제된 공간은 dummy space**로 활용되는데, 그렇기 때문에 **해시 테이블을 재정리해주는 작업이 필요**하다.

## 시간복잡도
각각의 key 값은 해시 함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 **O(1)의 시간복잡도로 데이터를 조회**할 수 있다.

하지만 **데이터의 충돌이 발생한 경우 chaining에 연결된 리스트들까지 검색을 해야 하므로 O(N)까지 시간복잡도가 증가**할 수 있다.

충돌을 방지하는 방법들은 데이터의 규칙성을 방지하기 위한 방식이지만 공간을 많이 사용한다는 단점이 있다.

만약 테이블이 꽉 차있는 경우라면 테이블을 확장해주어야 하는데, 이는 매우 심각한 성능의 저하를 불러오기 때문에 가급적이면 확장을 하지 않도록 테이블을 설계해주어야 한다.

## 참고
- https://mangkyu.tistory.com/102
